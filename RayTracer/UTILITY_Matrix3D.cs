//000000000000000000000000000000000000000000000000000000000000000000000
//000000000000000000011000000000011000000000000000000000000000000000000
//000000011111100000101000110000111000011000000000001111110000000000000
//000000100001100001010000110001110000110000000000001000111100000000000
//000011000001100010100001110011010000110000000000001100001100000000000
//000011000011000111000000100010100001110000001110001100111000010000000
//000110000011001110100000100011000000100000110100001111000001111000000
//000110000000001101100111100110000101100000110001111100000010011011000
//000011000000111110111001111001111001100011111110011111001100010100000
//000011111111001100000001100001100001111110001000010001110000111000000
//000000011000000000000000000000000001111000000000010000011100111000000
//000000000000000000000000000000000000000000000000000000000001011000000
//000000000000000000000000000000000000000000000000000000000010110000000
//(c) 2004 by Riley T. Perry - Chillers of Entropy

using System;

namespace RayTracer
{
	/// <summary>
	/// Matrix3D utility class
	/// </summary>
	public class Matrix3D
	{
		// *---------------------------------------*
		// Matrix3D Description
		// *---------------------------------------*

		// - Various matrix operations

		// *---------------------------------------*
		// Global Variables
		// *---------------------------------------*

		// -> The float type can represent values ranging from approximately 1.5 × 10-45 to 3.4 × 1038 with a precision of 7 digits.
		// -> The double type can represent values ranging from approximately 5.0 × 10-324 to 1.7 × 10308 with a precision of 15-16 digits.
		
		// x, y, and z coordinates
		public double[,] m = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}}; 

		// *---------------------------------------*
		// Constructor
		// *---------------------------------------*

		public Matrix3D()
		{
		}

		// *---------------------------------------*
		// Various function(s)
		// *---------------------------------------*
		/// <summary>
		/// MakeIdentityMatrix 
		/// </summary>
		public void MakeIdentityMatrix()
		{
			double[,] mnew = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; 
			m = mnew;
		}

		// *---------------------------------------*
		// Matrix operations, operators are 
		// overloaded
		// *---------------------------------------*
	
		/// <summary>
		/// Matrix multiplication m1 * m2 
		/// </summary>
		public static Matrix3D operator * (Matrix3D m1, Matrix3D m2)
		{
			Matrix3D sol = new Matrix3D();

			sol.m[0,0] = m1.m[0,0]*m2.m[0,0] + m1.m[0,1]*m2.m[1,0] + m1.m[0,2]*m2.m[2,0] + m1.m[0,3]*m2.m[3,0];    
			sol.m[0,1] = m1.m[0,0]*m2.m[0,1] + m1.m[0,1]*m2.m[1,1] + m1.m[0,2]*m2.m[2,1] + m1.m[0,3]*m2.m[3,1]; 
			sol.m[0,2] = m1.m[0,0]*m2.m[0,2] + m1.m[0,1]*m2.m[1,2] + m1.m[0,2]*m2.m[2,2] + m1.m[0,3]*m2.m[3,2]; 
			sol.m[0,3] = m1.m[0,0]*m2.m[0,3] + m1.m[0,1]*m2.m[1,3] + m1.m[0,2]*m2.m[2,3] + m1.m[0,3]*m2.m[3,3]; 
			sol.m[1,0] = m1.m[1,0]*m2.m[0,0] + m1.m[1,1]*m2.m[1,0] + m1.m[1,2]*m2.m[2,0] + m1.m[1,3]*m2.m[3,0]; 
			sol.m[1,1] = m1.m[1,0]*m2.m[0,1] + m1.m[1,1]*m2.m[1,1] + m1.m[1,2]*m2.m[2,1] + m1.m[1,3]*m2.m[3,1]; 
			sol.m[1,2] = m1.m[1,0]*m2.m[0,2] + m1.m[1,1]*m2.m[1,2] + m1.m[1,2]*m2.m[2,2] + m1.m[1,3]*m2.m[3,2]; 
			sol.m[1,3] = m1.m[1,0]*m2.m[0,3] + m1.m[1,1]*m2.m[1,3] + m1.m[1,2]*m2.m[2,3] + m1.m[1,3]*m2.m[3,3];   
			sol.m[2,0] = m1.m[2,0]*m2.m[0,0] + m1.m[2,1]*m2.m[1,0] + m1.m[2,2]*m2.m[2,0] + m1.m[2,3]*m2.m[3,0];
			sol.m[2,1] = m1.m[2,0]*m2.m[0,1] + m1.m[2,1]*m2.m[1,1] + m1.m[2,2]*m2.m[2,1] + m1.m[2,3]*m2.m[3,1];
			sol.m[2,2] = m1.m[2,0]*m2.m[0,2] + m1.m[2,1]*m2.m[1,2] + m1.m[2,2]*m2.m[2,2] + m1.m[2,3]*m2.m[3,2];
			sol.m[2,3] = m1.m[2,0]*m2.m[0,3] + m1.m[2,1]*m2.m[1,3] + m1.m[2,2]*m2.m[2,3] + m1.m[2,3]*m2.m[3,3];
			sol.m[3,0] = m1.m[3,0]*m2.m[0,0] + m1.m[3,1]*m2.m[1,0] + m1.m[3,2]*m2.m[2,0] + m1.m[3,3]*m2.m[3,0];
			sol.m[3,1] = m1.m[3,0]*m2.m[0,1] + m1.m[3,1]*m2.m[1,1] + m1.m[3,2]*m2.m[2,1] + m1.m[3,3]*m2.m[3,1];
			sol.m[3,2] = m1.m[3,0]*m2.m[0,2] + m1.m[3,1]*m2.m[1,2] + m1.m[3,2]*m2.m[2,2] + m1.m[3,3]*m2.m[3,2];
			sol.m[3,3] = m1.m[3,0]*m2.m[0,3] + m1.m[3,1]*m2.m[1,3] + m1.m[3,2]*m2.m[2,3] + m1.m[3,3]*m2.m[3,3];

			return sol;
		}

		/// <summary>
		/// Matrix * scalar multiplication (m1 * s) 
		/// </summary>
		public static Matrix3D operator * (Matrix3D m1, double s)
		{
			Matrix3D sol = new Matrix3D();

			for (int i=0;i<=3;i++)
			{
				for (int j=0;j<=3;j++)
				{
					sol.m[i, j] = m1.m[i, j] * s;
				}
			}
			return sol;
		}
	}
}